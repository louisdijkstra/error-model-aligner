#!/usr/bin/env python

"""
Copyright (C) 2015 Louis Dijkstra

This file is part of error-model-aligner

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
"""

from __future__ import print_function, division
from optparse import OptionParser
import os
import sys

from collections import defaultdict

sys.path.insert(0, os.path.abspath(os.path.dirname(__file__))[:-3] + 'python')

from Indel import *
from Alignments import *
from BAMProcessor import *

__author__ = "Louis Dijkstra"

usage = """%prog [options] <raw-observation-file> <result-dir>

	<raw-observation-file> 	File with raw observations. 
			File is generated by 'extract-raw-observations.py'
	<result-dir> 		Path to the folder that will contain
			all the output files. 

The output contains of all (potentially) large number of files. The filenames 
follow the following pattern: 

	{deletion/insertion}.length<indel-length>

I.e., the deletions and insertions of a certain length <indel-length> have their
own files. The extension of the file reflect the data it contains: 

	.n-obs - the number of reads that were aligned by the aligner
	.n-insert-size-obs - the number of insert size alignments
	.n-overlapping-obs - the number of overlapping alignments with the indel
	.n-deletion-splits - number of overlapping alignments that contain a deletion split
	.n-insertion-splits - number of overlapping alignments that contain an insertion split
	
	.insert-sizes - the insert sizes 
	.length-deletion-splits - the length of the deletion splits found
	.length-insertion-splits - the length of the insertion splits found
	.dist-centerpoints-del-splits - the distance between the deletion split and the indel's centerpoint
	.dist-centerpoints-ins-splits - the distance between the insertion split and the indel's centerpoint

Every file is organized in two column (tab-seperated): 

	x_1	c_1
	x_2	c_2
	...	...
	x_n	c_n

where x_1 is the minimal value found and x_n is the maximum value found. (Note: x_{i+1} = x_i + 1). 
c_i is the count for x_i. 

In case there are no such observations, the file remains empty. 
"""

class CountData:

	def __init__(self):
		self.n = 0 # number of data points added
		self.min_value = float('Inf')
		self.max_value = float('-Inf')
		self.count = defaultdict(int)	

	def add(self, value, count):
		self.n += 1 
		if value < self.min_value: 
			self.min_value = value 
		if value > self.max_value:
			self.max_value = value 
		self.count[value] += count

	def print(self, output_stream):
		outputfile = open(output_stream, 'w') 
		if self.n == 0:
			return 0
		for i in range(self.min_value, self.max_value + 1):
			print("%d\t%d"%(i, self.count[i]), file=outputfile) 
		


def main():
	parser = OptionParser(usage=usage)
	(options, args) = parser.parse_args()

	if (len(args)!=2):
		parser.print_help()
		return 1

	raw_observations_file = open(args[0], 'r')
	result_dir = args[1] 
	if result_dir[-1] != '/':
		result_dir += '/'

	# initialize data holders: 
	del_n_obs 			= defaultdict(CountData)
	del_n_insert_size_obs		= defaultdict(CountData)
	del_n_overlapping_obs		= defaultdict(CountData)
	del_n_deletion_split_obs	= defaultdict(CountData)
	del_n_insertion_split_obs	= defaultdict(CountData)
	
	del_insert_sizes 		= defaultdict(CountData)
	del_length_deletion_splits	= defaultdict(CountData)
	del_length_insertion_splits	= defaultdict(CountData)
	del_dist_centerpoint_del_splits = defaultdict(CountData)
	del_dist_centerpoint_ins_splits = defaultdict(CountData)

	ins_n_obs 			= defaultdict(CountData)
	ins_n_insert_size_obs		= defaultdict(CountData)
	ins_n_overlapping_obs		= defaultdict(CountData)
	ins_n_deletion_split_obs	= defaultdict(CountData)
	ins_n_insertion_split_obs	= defaultdict(CountData)
	
	ins_insert_sizes 		= defaultdict(CountData)
	ins_length_deletion_splits	= defaultdict(CountData)
	ins_length_insertion_splits	= defaultdict(CountData)
	ins_dist_centerpoint_del_splits = defaultdict(CountData)
	ins_dist_centerpoint_ins_splits = defaultdict(CountData)

	# process the raw observations file and store the data in the data holders 
	
	n_obs = 0 
	while (True):
		line = raw_observations_file.readline() 
		if not line: # end of file reached
			break 

		values = line.split() 
		if values[0].strip() != '-' and values[0].strip() != '+': # go on till you find the next indel
			continue
			
		n_obs += 1 
		if (n_obs % 10000 == 0):
			print("Processed number of variants: %d"%n_obs) 

		is_deletion = (values[0].strip() == '-')
		length = int(values[1]) # indel length
	
		# NEXT LINE === NUMBER OF OBSERVATIONS AND THEIR TYPES === 
		values = map(int, raw_observations_file.readline().split())
		if (is_deletion):
			del_n_obs[length].add(values[0] + values[1], 1) 
			del_n_insert_size_obs[length].add(values[0], 1) 
			del_n_overlapping_obs[length].add(values[1], 1)
			del_n_deletion_split_obs[length].add(values[2], 1)
			del_n_insertion_split_obs[length].add(values[3], 1)
		else: 
			ins_n_obs[length].add(int(values[0]) + int(values[1]), 1) 
			ins_n_insert_size_obs[length].add(int(values[0]), 1) 
			ins_n_overlapping_obs[length].add(int(values[1]), 1)
			ins_n_deletion_split_obs[length].add(int(values[2]), 1)
			ins_n_insertion_split_obs[length].add(int(values[3]), 1)
		
		# NEXT LINE === INSERT SIZES === 
		values = map(int, raw_observations_file.readline().split())
		if (is_deletion):
			for insert_size in values:
				del_insert_sizes[length].add(insert_size, 1) 
		else: 
			for insert_size in values:
				ins_insert_sizes[length].add(insert_size, 1) 

		# NEXT LINE === LENGTH OF THE DELETION SPLITS === 
		values = map(int, raw_observations_file.readline().split())
		if (is_deletion):
			for x in values:
				del_length_deletion_splits[length].add(x, 1) 
		else: 
			for x in values:
				ins_length_deletion_splits[length].add(x, 1) 

		# NEXT LINE === DISTANCE BETWEEN CENTERPOINT INDEL AND CENTERPOINT DELETION SPLIT === 
		values = map(int, raw_observations_file.readline().split()) 
		if (is_deletion):
			for x in values:
				del_dist_centerpoint_del_splits[length].add(x, 1) 
		else: 
			for x in values:
				ins_dist_centerpoint_del_splits[length].add(x, 1) 

		# NEXT LINE === LENGTH OF THE INSERTION SPLITS === 
		values = map(int, raw_observations_file.readline().split()) 
		if (is_deletion):
			for x in values:
				del_length_insertion_splits[length].add(x, 1) 
		else: 
			for x in values:
				ins_length_insertion_splits[length].add(x, 1) 

		# NEXT LINE === DISTANCE BETWEEN CENTERPOINT INDEL AND CENTERPOINT INSERTION SPLIT === 
		values = map(int, raw_observations_file.readline().split()) 
		if (is_deletion):
			for x in values:
				del_dist_centerpoint_ins_splits[length].add(x, 1) 
		else: 
			for x in values:
				ins_dist_centerpoint_ins_splits[length].add(x, 1) 


	# PRINT THE DATA TO FILES | DELETIONS FIRST
	for length in del_n_obs.keys():
		output_file = result_dir + 'deletion.length' + str(length)
		del_n_obs[length].print(output_file + '.n-obs') 
		del_n_insert_size_obs[length].print(output_file + '.n-insert-size-obs') 
		del_n_overlapping_obs[length].print(output_file + '.n-overlapping-obs') 
		del_n_deletion_split_obs[length].print(output_file + '.n-deletion-splits') 
		del_n_insertion_split_obs[length].print(output_file + '.n-insertion-splits') 
		del_insert_sizes[length].print(output_file + '.insert-sizes') 
		del_length_deletion_splits[length].print(output_file + '.length-deletion-splits') 
		del_length_insertion_splits[length].print(output_file + '.length-insertion-splits') 
		del_dist_centerpoint_del_splits[length].print(output_file + '.dist-centerpoints-del-splits') 
		del_dist_centerpoint_ins_splits[length].print(output_file + '.dist-centerpoints-ins-splits') 

	
	# PRINT THE DATA TO FILES | INSERTIONS
	for length in del_n_obs.keys():
		output_file = result_dir + 'insertion.length' + str(length)
		ins_n_obs[length].print(output_file + '.n-obs') 
		ins_n_insert_size_obs[length].print(output_file + '.n-insert-size-obs') 
		ins_n_overlapping_obs[length].print(output_file + '.n-overlapping-obs') 
		ins_n_deletion_split_obs[length].print(output_file + '.n-deletion-splits') 
		ins_n_insertion_split_obs[length].print(output_file + '.n-insertion-splits') 
		ins_insert_sizes[length].print(output_file + '.insert-sizes') 
		ins_length_deletion_splits[length].print(output_file + '.length-deletion-splits') 
		ins_length_insertion_splits[length].print(output_file + '.length-insertion-splits') 
		ins_dist_centerpoint_del_splits[length].print(output_file + '.dist-centerpoints-del-splits') 
		ins_dist_centerpoint_ins_splits[length].print(output_file + '.dist-centerpoints-ins-splits') 
	


if __name__ == '__main__':
	sys.exit(main())
